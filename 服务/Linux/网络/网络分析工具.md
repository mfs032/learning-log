# 基本分析工具

## ping

```bash
发送ICMP包，检测主机是否可达
-c	指定次数
-i	设置间隔
-s	设置包大小
```

```bash
root@server15128:~# ping 3.225.11.26 -c 5 -i 5 -s 64 
PING 3.225.11.26 (3.225.11.26) 64(92) bytes of data.
72 bytes from 3.225.11.26: icmp_seq=1 ttl=58 time=6.95 ms
72 bytes from 3.225.11.26: icmp_seq=2 ttl=58 time=6.94 ms
72 bytes from 3.225.11.26: icmp_seq=3 ttl=58 time=6.92 ms
72 bytes from 3.225.11.26: icmp_seq=4 ttl=58 time=6.95 ms
72 bytes from 3.225.11.26: icmp_seq=5 ttl=58 time=6.93 ms

--- 3.225.11.26 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 20013ms
rtt min/avg/max/mdev = 6.924/6.939/6.952/0.011 ms
```





## Traceroute

```bash
用于追踪数据包从你的电脑到目标服务器所经过的路径。这个路径由一系列的路由器组成，每个路由器都是一个“跳”（hop）。通过Traceroute，你可以看到数据包经过了哪些跳，以及到达每个跳所花费的时间，从而帮助你诊断网络延迟或连接问题。



Traceroute向目标地址发送一系列数据包，并故意将每个数据包的“生存时间”（TTL，Time To Live）值设置为递增。
第一个数据包的TTL设为1。当它到达第一个路由器时，路由器会因为TTL过期而丢弃它，并向你的电脑发送一个“TTL已过期”的错误消息。Traceroute通过这个错误消息来识别第一个跳，并记录往返时间。
第二个数据包的TTL设为2。它会经过第一个路由器，到达第二个路由器，然后被丢弃。你的电脑会收到第二个路由器的错误消息，并记录时间。
这个过程一直重复，直到数据包成功到达目标服务器。



用户访问网站慢，通过 traceroute可以发现延迟是发生在运营商网络还是自身机房出口。


可被mtr替代
```

## mtr

```
MTR (My Traceroute) 是一个结合了 ping 和 traceroute 功能的网络诊断工具。它能持续发送数据包，实时显示从你的电脑到目标服务器的路径上每个节点的延迟和丢包率，这使得它在诊断网络问题时比 traceroute 更加强大和直观。
```

### 基本用法

```bash
mtr [目标IP或域名]

mtr 8.8.8.8
mtr example.com
#运行后会进入交互模式，实时显示数据

Host              Loss%   Snt   Last   Avg  Best  Wrst StDev
1. 192.168.1.1     0.0%    10    1.2   1.3   1.1   1.5   0.1
2. 10.0.0.1        0.0%    10    5.1   5.3   4.8   6.0   0.4
3. 203.0.113.1     10.0%   10   15.2  16.1  14.8  18.3   1.2

Host：路由跳转的节点 IP 或主机名。
Loss%：该节点的丢包率（重点关注高丢包率节点）。
Snt：已发送的数据包数量。
Last/Avg/Best/Wrst：最近/平均/最佳/最差延迟（单位：ms）。
StDev：延迟的波动程度（值越大，网络越不稳定）。
```

### 常用参数

```
-c [次数]		指定发送的包数量
-i [秒]		设置发包间隔（默认 1 秒）
-n			禁用 DNS 反向解析（直接显示 IP，加快输出）
-4/-6		强制使用 IPv4 或 IPv6
-r			生成报告模式，输出到命令行
```

```
mtr -l -c 3 -i 1 -4 -n 8.8.8.8
```



### 高级参数

```
-a [IP]		设置源 IP（多网卡时指定出口）
-T			使用 TCP SYN 包（替代默认的 ICMP）
-P [端口]		配合 -T指定 TCP 端口
-u			使用 UDP 包（替代 ICMP）
-w			宽输出模式（显示更详细的信息）
```

```
mtr -l -T -P 443 example.com  # 使用 TCP 443 端口测试（模拟 HTTPS 访问）
```



## dig

```bash
dig [域名]
dig example.com
#输出会显示该域名的 A 记录（IPv4 地址）、查询的 DNS 服务器、响应时间等信息。
```

```
[root@ip-172-31-17-223 ~]# dig proxy.mryas6.com

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.16 <<>> proxy.mryas6.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 17674
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;proxy.mryas6.com.      IN  A

;; ANSWER SECTION:
proxy.mryas6.com.   21  IN  A   52.44.5.246

;; Query time: 0 msec
;; SERVER: 172.31.0.2#53(172.31.0.2)
;; WHEN: Thu Sep 18 15:50:40 UTC 2025
;; MSG SIZE  rcvd: 61


1. Command Line and Global Options
; <<>> DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.16 <<>> proxy.mryas6.com
;; global options: +cmd
DiG 9.11.4-P2...：显示了你使用的 dig 工具的版本。
proxy.mryas6.com：显示了你 查询的域名。
global options: +cmd：这是你执行命令时使用的全局选项。+cmd 选项告诉 dig 仅在命令行模式下显示查询结果，这是默认行为。


2. Header Section
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 17674
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
这部分是 DNS 响应包的头部信息
opcode: QUERY：表示这是一个 标准查询。

status: NOERROR：这是最重要的信息。它表明 DNS 服务器成功地找到了查询的记录，并且没有错误。如果这里显示 NXDOMAIN，则表示域名不存在。
id: 17674：查询的 ID，用于匹配 DNS 请求和响应。
flags：DNS 响应标志。
qr (query response)：表示这是一个响应包。
rd (recursion desired)：表示客户端希望 DNS 服务器进行 递归查询。
ra (recursion available)：表示 DNS 服务器 支持递归查询。
QUERY: 1：查询的数量，这里是1，表示只查询了一个域名。
ANSWER: 1：答案的数量，这里是1，表示找到了一个 A 记录（IP 地址）。
AUTHORITY: 0：权威记录的数量，这里是0，表示这个响应不是来自权威 DNS 服务器。
ADDITIONAL: 1：附加记录的数量，这里是1，通常是和 OPT PSEUDOSECTION 有关。


3. OPT PSEUDOSECTION
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
EDNS (Extension mechanisms for DNS) 的信息。EDNS 是一种扩展，用于突破传统 DNS 512 字节的限制，允许传输更大的 DNS 消息，并支持新的标志和选项。
EDNS: version: 0：EDNS 版本号，目前是0。
flags:：EDNS 标志，这里为空。
udp: 4096：表示客户端可以接收最大 4096 字节 的 UDP 响应包。


4. QUESTION SECTION
;; QUESTION SECTION:
;proxy.mryas6.com.      IN      A
;proxy.mryas6.com.：再次确认了你 查询的域名。
IN：表示 互联网（Internet）类型。
A：表示 记录类型。A 记录用于将域名映射到 IPv4 地址。如果你查询的是 NS、MX、AAAA 或其他类型，这里就会相应地改变。


5. ANSWER SECTION
;; ANSWER SECTION:
proxy.mryas6.com.   21  IN  A   52.44.5.246
这是 DNS 查询的答案
proxy.mryas6.com.：返回的域名。
21：这是 TTL (Time To Live)，生存时间。单位是秒。它告诉你的本地 DNS 解析器或浏览器可以将这个结果 缓存 多长时间。在这里，这个 IP 地址可以被缓存21秒，之后需要重新查询。
IN：互联网类型。
A：记录类型，这里是 IPv4 地址。
52.44.5.246：DNS 解析后得到的 IPv4 地址


6. Server and Query Statistics
;; Query time: 0 msec
;; SERVER: 172.31.0.2#53(172.31.0.2)
;; WHEN: Thu Sep 18 15:50:40 UTC 2025
;; MSG SIZE  rcvd: 61
这部分提供了关于本次查询的统计信息。
Query time: 0 msec：本次查询花费的 时间，单位是毫秒。这里是0毫秒，表示是从本地 DNS 缓存中直接获取的。
SERVER: 172.31.0.2#53(172.31.0.2)：本次查询的 DNS 服务器地址。#53 是 DNS 的标准端口号。
WHEN: Thu Sep 18...：查询的 时间。
MSG SIZE rcvd: 61：接收到的 DNS 响应包的 大小，单位是字节。
总的来说，你提供的 dig 输出显示了一次非常成功且快速的 DNS 查询。它从一个本地 DNS 服务器 (172.31.0.2) 成功获取了 proxy.mryas6.com 的 IPv4 地址 (52.44.5.246)，并且由于查询时间是0毫秒，说明这个结果是直接从本地 DNS 缓存中返回的。
```

### 查询指定记录类型

```bash
DNS 记录类型包括：
A：IPv4 地址
AAAA：IPv6 地址
MX：邮件服务器
CNAME：别名记录
TXT：文本记录（常用于验证或 SPF 配置）
NS：域名服务器
SOA：域权威信息

dig [域名] [记录类型]

dig example.com MX	#查询邮件服务器记录
dig example.com TXT #查询TXT记录
dig example.com NS  #查询域名服务器
```

### 指定DNS服务器查询

```bash
默认情况下，dig会使用/etc/resolv.conf中配置的DNS服务器
dig @[DNS服务器] [域名]
dig @8.8.8.8 example.com	#使用Google DNS查询
dig @1.1.1.1 example.com	#使用CF DNS查询
dig @ns1.example.com example.com	#直接查询权威DNS
```

### 精简输出

```bash
dig example.com +short

[root@ip-172-31-17-223 ~]# dig proxy.mryas6.com +short
52.44.5.246
```

### 显示详细的调试信息

```bash
dig example.com +trace
#+trace可以模拟 DNS 递归查询过程，显示从根域名服务器开始的完整解析路径
[root@ip-172-31-17-223 ~]# dig proxy.mryas6.com +trace

; <<>> DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.16 <<>> proxy.mryas6.com +trace
;; global options: +cmd
.           21  IN  NS  k.root-servers.net.
.           21  IN  NS  l.root-servers.net.
.           21  IN  NS  m.root-servers.net.
.           21  IN  NS  a.root-servers.net.
.           21  IN  NS  b.root-servers.net.
.           21  IN  NS  c.root-servers.net.
.           21  IN  NS  d.root-servers.net.
.           21  IN  NS  e.root-servers.net.
.           21  IN  NS  f.root-servers.net.
.           21  IN  NS  g.root-servers.net.
.           21  IN  NS  h.root-servers.net.
.           21  IN  NS  i.root-servers.net.
.           21  IN  NS  j.root-servers.net.
;; Received 239 bytes from 172.31.0.2#53(172.31.0.2) in 0 ms

com.            172800  IN  NS  a.gtld-servers.net.
com.            172800  IN  NS  b.gtld-servers.net.
com.            172800  IN  NS  c.gtld-servers.net.
com.            172800  IN  NS  d.gtld-servers.net.
com.            172800  IN  NS  e.gtld-servers.net.
com.            172800  IN  NS  f.gtld-servers.net.
com.            172800  IN  NS  g.gtld-servers.net.
com.            172800  IN  NS  h.gtld-servers.net.
com.            172800  IN  NS  i.gtld-servers.net.
com.            172800  IN  NS  j.gtld-servers.net.
com.            172800  IN  NS  k.gtld-servers.net.
com.            172800  IN  NS  l.gtld-servers.net.
com.            172800  IN  NS  m.gtld-servers.net.
com.            86400   IN  DS  19718 13 2 8ACBB0CD28F41250A80A491389424D341522D946B0DA0C0291F2D3D7 71D7805A
com.            86400   IN  RRSIG   DS 8 1 86400 20251001050000 20250918040000 46441 . duoJ2goM3cI/3I9ZB93sUFPdWClvVyZZW2ykuV7UpQ91O4WMJWTmBxka 9YN7Cj+wW74szT4nISHBB0ts8o0q3K9r1BJNuzJrGqeHsz6PlwD1Z+Ev KRwrhUhiipVuBLncIjm5uOKdP/Du1VYwPBpwKT5rIeqBCUKEbclmOVn0 IG8JTOVHzQFwrxRCz64zZIPLvffjLTj3Y7MUDkFwAex/eoTaUrTl8ddC cIw9FvkUTEuI0Cbs02wqMUymELEQRVQ8kkUdST5uPoC3LEJCcwrozrJ6 Ie1PEk+c8ty5UCQRrFnMQsvH6rWe+wANvlXw8qaZhXc/4GsRPiAv2Kyr 23aMug==
;; Received 1176 bytes from 198.97.190.53#53(h.root-servers.net) in 4 ms

mryas6.com.     172800  IN  NS  ns-281.awsdns-35.com.
mryas6.com.     172800  IN  NS  ns-998.awsdns-60.net.
mryas6.com.     172800  IN  NS  ns-1594.awsdns-07.co.uk.
mryas6.com.     172800  IN  NS  ns-1378.awsdns-44.org.
CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 900 IN NSEC3 1 1 0 - CK0Q3UDG8CEKKAE7RUKPGCT1DVSSH8LL NS SOA RRSIG DNSKEY NSEC3PARAM
CK0POJMG874LJREF7EFN8430QVIT8BSM.com. 900 IN RRSIG NSEC3 13 2 900 20250924002611 20250916231611 20545 com. pd4Ns+LJVpNSAHkyxMDNDOxfu+SCWzDKiGmIPpFEFNQYIqbUT1YR/YbZ xhsdKXXTjSxDU5qrOVpaGIQX0l4M/Q==
VHAL6GC8BO91QHA2RHRPQ81DT1T4K7KF.com. 900 IN NSEC3 1 1 0 - VHALBP0N5KIM9OSFNA29UMF10BSJ920S NS DS RRSIG
VHAL6GC8BO91QHA2RHRPQ81DT1T4K7KF.com. 900 IN RRSIG NSEC3 13 2 900 20250922021308 20250915010308 20545 com. 2p16Z+HKv5IgXenAHf4XrSO28kULX8sKdSnadFdsFO22CDMuWilDzyU3 7cca5UjB+k1+4Vk1XTZG05BY+l8DzA==
;; Received 555 bytes from 192.48.79.30#53(j.gtld-servers.net) in 6 ms

proxy.mryas6.com.   300 IN  A   52.44.5.246
mryas6.com.     172800  IN  NS  ns-1378.awsdns-44.org.
mryas6.com.     172800  IN  NS  ns-1594.awsdns-07.co.uk.
mryas6.com.     172800  IN  NS  ns-281.awsdns-35.com.
mryas6.com.     172800  IN  NS  ns-998.awsdns-60.net.
;; Received 198 bytes from 205.251.195.230#53(ns-998.awsdns-60.net) in 11 ms
```

### 批量查询（从文件读取域名）

```bash
#使用while
while read domain; do dig $domain +short; done < domains.txt

#使用-f 参数
dig -f domains.txt + short
```



## ss

```bash
ss（Socket Statistics）是 Linux 下用于查看网络连接信息的现代工具
```

### 基本用法

```
ss [选项]
默认不加参数时，ss会显示所有已建立的连接，也就是套接字，套接字就是用来网络通信的文件
```

### 常用选项

#### 按照协议过滤

```bash
-t	显示TCP连接
-u	显示UDP连接
-w	显示RAW套接字
-x	显示Unix域套接字(本地进程通信)
```

```
] ss -x
[root@ip-172-31-17-223 ~]# ss -x
Netid  State      Recv-Q Send-Q        Local Address:Port              Peer Address:Port                      
u_str  ESTAB      0      0                                                    /var/run/salt/minion/minion_event_d9c7a659b2_pub.ipc 1111283770        * 1111282897


Netid	套接字类型，类似TCP，但不通过网络，用于本机进程间通信
Recv-Q 和 Send-Q	接受和发送队列，都为0是好事，说明套接字缓冲区没有积压的待处理数据

Local Address:Port 和 Peer Address:Port	本地和对端的套接字地址

/var/run/salt/minion/minion_event_d9c7a659b2_pub.ipc	已命名的 Unix 域套接字

1111283770 本地端点，套接字的inode

*	对端的套接字，是未命名套接字，没有一个可直接通过文件路径访问的名称，建立连接时动态创建，断开连接后销毁

1111282897	对端套接字的inode
```

```
ss -w
通常，应用程序通过标准套接字（例如 TCP 或 UDP）进行网络通信。这些套接字由操作系统处理，自动处理网络协议栈的细节（比如 TCP 的三次握手、数据包分段和重组等）。
而原始套接字则是一种更底层的套接字类型。它允许应用程序直接访问 IP 层，这意味着程序可以绕过传输层协议（如 TCP 或 UDP），直接发送和接收 IP 数据包。这对于一些特殊的网络工具非常有用，例如ping，wireshark，tcpdump
```

```bash
ss -t和ss -u
[root@ip-172-31-17-223 ~]# ss -t
State      Recv-Q Send-Q                     Local Address:Port               Peer Address:Port                
ESTAB      0      0                          172.31.17.223:35242              104.237.142.233:4505                 
ESTAB      0      0                          172.31.17.223:39574              172.233.183.254:17000

State	是TCP连接状态
Listen	是服务器正在等待客户端连接
ESTAB	已成功建立连接
TIME-WAIT	连接已关闭，但套接字任等待一段时间，确保所有数据包已处理

UNCONN	表示UDP连接，即无连接，没有握手和状态转换
```

#### 按照连接状态过滤

```bash
-a	显示所有连接
-l	仅显示监听状态的端口
-s	显示统计信息(总结各类连接数量)

ss -ltn	#显示所有监听的TCP端口，n表示不解析服务名和主机名，例如80不会被解析为http，22不会被解析为ssh
```

#### 显示进程信息

```bash
-p	显示端口占用的进程信息，会在每行结尾添加user(...)，()里是类似("sshd",pid=12345,fd=3)的内容，为sshd进程创建,进程号12345，并且套接字是该进程的文件描述符fd=3

-e 	显示套接字的扩展信息，例如uid:995 ino:1551353107 sk:ffff8d19f5176b40 v6only:1 <->，ino是这个套接字的inode，sk该套接字的缓冲区，v6only:1中的1表示v6only置为真，表示该套接字只监听IP
v6的流量
LISTEN      0      4096      [::]:19126     [::]:*   uid:114 ino:358430 sk:9 cgroup:/system.slice/zabbix-agent.service v6only:1 <->

这个[::]:19126当v6only关闭时，可以同时监听v4和v6的流量，当v6only打开时，只能监听v6的流量
```

#### 按照IP/端口过滤

```
ss -t dst 8.8.8.8	#到8.8.8.8的连接
ss -t src 192.168.1.100	#来自192.168.1.100的连接
ss -t dport :80	#查看到目标80端口的连接
```



## lsof

```bash
lsof（LiSt Open Files）是 Linux/Unix 系统中一个强大的命令行工具，用于列出当前系统打开的文件。lsof不仅可以查看普通文件，还能显示网络连接、管道、套接字、设备等所有被进程打开的资源。

lsof [选项]
不加任何参数时，lsof会列出系统中所有被打开的文件（信息量极大，慎用）。
```

### 常用选项

```bash
#按用户过滤
-u [用户名]	#显示指定用户打开的文件
-u ^[用户名]	#排除指定用户
lsof -u root
lsof -u ^root

#按进程过滤
-c [进程名]	显示指定进程打开的文件
-p [进程号]	显示指定进程ID打开的文件
lsof -c nginx	#查看所有nginx进程打开的文件
lsof -p 1234	#显示指定进程ID打开的文件

#按文件或目录过滤
[文件名]	#查看谁在访问该文件
+D [目录]		#查看谁在访问该目录下的文件(递归)
lsof /var/log/syslog	#查看谁在使用该文件
lsof +D /var/log	#查看所有访问/var/log目录下所有被打开的文件

#按网络连接过滤
-i	#查看所有网络连接(TCP/UDP)
-i :[端口]	#查看指定端口的连接
-i @[IP]	#查看指定IP的连接
lsof -i
lsof -i :80
lsof -i @8.8.8.8
```

### 输出格式

```bash
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
nginx   1234 root    6u  IPv4 123456      0t0  TCP *:80 (LISTEN)
zabbix_ag 1514 zabbix  txt    REG  202,1   573008 276421 /usr/sbin/zabbix_agentd

COMMAND：进程名称（如 nginx）。
PID：进程 ID。
USER：运行进程的用户。
FD：文件描述符（File Descriptor），常见值：
	cwd：当前工作目录。
	txt：程序代码（如二进制文件）。
	mem：内存映射文件。
	0u/1u/2u：标准输入/输出/错误。
	3u：普通文件或套接字。
TYPE：文件类型，如：
	REG：普通文件。
	DIR：目录。
	IPv4/IPv6：网络套接字。
	unix：Unix 域套接字（本地进程通信）。
DEVICE：设备号（主设备号:次设备号）。
SIZE/OFF：文件大小或偏移量。
NODE：文件的 inode 号。
NAME：文件或网络连接的详细信息（如路径、IP:端口）。
```

### 一些用法

```bash
查看已删除但仍被进程占用的文件
lsof | grep deleted
示例输出
nginx   1234 root    1w   REG  253,1    12345 123456 /var/log/nginx/error.log (deleted)
```



# 分析包工具

## tcpdump











## Tshark(wireshark命令行版)