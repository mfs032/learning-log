# 机制说明

```
API Server是集群内部各个组件通信的中介，也是外部控制的入口。安全机制是围绕API Server设计的
分为认证、鉴权、准入控制
```



# 认证(Authentication)

```
确认身份
认证模式的类型：
组件访问：
	HTTP Token 认证：当客户端访问API Server时，需要在HTTP Header中放入Token
	HTTP Base 认证：将用户名密码经过BASE 64编码放入HTTP Request中的Hreder Authorization域里发送给服务端
	HTTPS证书认证：基于CA根证书签名的客户端身份认证

Pod访问：
	使用ServiceAccount
```

## HTTPS认证

```
HTTPS认证分类：
	单项 HTTPS 认证
		客户端认证服务器
			www.baidu.com
		
	双向 HTTPS 认证
		客户端与服务器端双向认证
			ATM机
```

## 需要认证的节点

```
Kubernetes组件对API Server的访问：kubectl 、Controller Manager、Scheduler、kubelet、kube-proxy

Controller Manager、Scheduler与API Server在同一台机器上,可以确定所在节点属于安全环境，所以直接使用API Server的非安全端口访问--insecure-bind-address=127.0.0.1
kubectl、kubelet、kube-proxy访问API Server就需要HTTPS双向认证

如果Controller Manager、Scheduler与API Server不在同一台机器上，不能确定所在节点是否安全，就需要通过HTTPS双向认证
```

## 证书签发模式

```
手动签发：通过k8s集群和CA进行签发HTTPS证书
自动签发：kubelet首次访问API Server时，使用Token作认证，通过后，Controller Manager会为kubelet生成一个证书，以后的访问都是用证书作认证

kubeadm安装模式，这个kubeadm会帮助安装者手动签发证书，不需要安装者自己手动签发
在使用kubeadm安装时，每个子节点会运行类似这个条指令：
] kubeadm join 192.168.66.11:6443 --token 4z4das.mnnev6qdfncist3s
--discovery-token-ca-cert-hash
shA256:0ce73d943deca9a939bec4e7fe1657c14f30538ee9e70832b1d4c8764fcd1b0c
--cri-socketunix:///var/run/cri-dockerd.sock

--token
	用于API Server验证kubelet的身份
--discovery-token-ca-cert-hash，指定的哈希值是API Server的服务器证书计算得到的
	用于kubelet确认API Server的身份，API Server将自己的服务器证书发给kubelet，kubelet使用这个哈希值校验API Server的证书是否正确
```

## kubeconfig

```
kubeconfig文件包含集群参数(CA证书、API Server地址)，客户端参数(上面生成的证书和私钥)，集群context信息(集群名称、用户名)。kubernetes组件通过启动时指定不同的kubeconfig文件可以切换到不同的集群

在kubernetes主节点的/etc/kubernetes/admin.conf文件就是kubeconfig文件类型，里面有集群管理员相关的凭据。将这个文件拷贝到Linux用户目录下，cp /etc/kubernetes/admin.conf /root/.kube/config
当在这台主机上使用root身份运行kubelet命令访问API Server时，就是使用对应root目录下.kube/config这个文件里的身份等信息访问
```

## Pod访问API Server

```
k8s组件使用HTTPS双向认证，因为这些组件是长期存在的。
Pod的存活时间不确定，手动创建证书不现实，所以不能使用HTTPS双向认证的方式，而是使用Service Account。
像DNS插件，calico都是以pod的形式运行的

Secret分为很多类，其中两类如下
Opaque：用于保存用户自定义的保密信息
service-account-token：用来给ServiceAccount关联的，其中包含
	token:使用API Server私钥签发的JWT。用于访问API Server端时，给Server端做认证
	ca.crt：根证书，给Client端验证API Server发送的证书是否合法
	namespace：表示该ServiceAccount所属命名空间

默认情况下，每个namespace都会有一个ServiceAccount，如果Pod在创建的时候没有指定ServiceAccount，就会使用Pod所属的namespace的ServiceAccount
] kubectl get sa -n test
有一个default的ServiceAccount已经准备好
```



# 鉴权(Authorization)

```
认证过程是确认通信双方都确认对方是可信的。鉴权是为了确认请求方有哪些资源的权限。
API Server支持以下几种授权策略(通过API Server的启动参数 "--authorization-mode"设置)
AlwaysDeny：拒绝所有请求，一般用于测试
AlwaysAllow：允许接受所有请求，如果集群不需要授权流程，可以采用该策略
ABAC(Attribute-Based Access Control)：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制，类似Linux文件的权限，一个个授权太麻烦，已不考虑
Webhook：通过调用外部的REST服务对用户进行授权，例如调用OpenStack的keystone
RBAC(Role-Based Access Control)：基于角色的访问控制，默认规则
```

## RBAC资源对象

```
RBAC引入了四个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding，四种对象类型都可以通过kubectl和API进行操作。
Role和RoleBinding是命名空间级别
ClusterRole和ClusterRoleBinding都是集群级别的
Resource											User
create--------->Role------->RoleBinding--------->	Group
get													ServiceAccount
update
被绑定的对象有用户，组，SA
```

## 绑定

```
Role + RoleBinding
ClusterRole + ClusterRoleBinding
ClusterRole + RoleBinding	#这种被绑定的角色只能在对应的命名空间下行使ClusterRole所赋予的权限，相当于第一种，只不过如果有多个命名空间，就不需要创建多个不同命名空间下的Role，直接复用这个ClusterRole。
```

## Role

```
在RBAC API中，Role表示一组规则权限，权限只会增加(累加权限)，不存在一个资源一开始就有很多权限而通过RBAC对其进行减少的操作；Role可以定义在一个namespace中，如果想要跨namespace则可以创建ClusterRole
```

### 例子

```yaml
kind: Role
apiversion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default # Role是命名空间级别的，需要声明命名空间
  name: pod-reader
rules:
- apiGroups: [""] # ""表示核心组 API Group
  resources: ["pods"] # 资源类别
  verbs: ["get", "watch", "list"] # 动作类别
```

## ClusterRole

```
ClusterRole具有与Role相同的权限角色控制能力，不同的是ClusterRole是集群级别的：可以用于集群级别的资源访问(例如node访问权限)，对非资源类型endpoints(例如/health访问)，所有命名空间资源控制(例如pods)
```

### 例子

```yaml
kind: ClusterRole
apiversion: rbac.authorization.k8s.io/v1beta1
metadata: 
  name: secret-reader	# 集群角色没有命名空间，不需要声明
rules:
- apigroups: [""]
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
```

## RoleBinding + Role

```
RoloBinding可以将角色中定义的权限授予用户或用户组，RoleBinding包含一组权限列表（subjects)，权
限列表中包含有不同形式的待授予权限资源类型(users,groups,orservice accounts);RoloBinding同样
包含对被Bind 的 Role 引用；RoleBinding适用于某个命名空间内授权，而ClusterRoleBinding适用于集
群范围内的授权
```

### 例子

```yaml
kind: RoleBinding
apiversion: rbac.authorization.k8s.io/vibetal
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: jane	#jane这个角色可以在default命名空间下使用pod-reader这个角色
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

## RoleBinding + ClusterRole

```
RoleBinding同样可以引用ClusterRole来对当前namespace内用户、用户组或ServiceAccount进行授
权，这种操作允许集群管理员在整个集群内定义一些通用的ClusterRole，然后在不同的namespace中使
用RoleBinding来引用
```

### 例子

```yaml
# This role binding allows "dave" to read secrets in the "development namespace.
kind: RoleBinding
apiversion: rbac.authorization.k8s.io/v1betal
metadata:
  name: read-secrets
  namespace: dev # This only grants permissions within the "development" namespace.
subjects:
- kind: User
  name: dave
 apiGroup: rbac.authorization.k8s.io
roleRef:
 kind: ClusterRole
 name: secret-reader
 apiGroup: rbac.authorization.k8s.io
```

## ClusterRoleBindning + ClusterRole

```
使用ClusterRoleBinding可以对整个集群中的所有命名空间资源权限进行授权；以下
ClusterRoleBinding样例展示了授权manager组内所有用户在全部命名空间中对secrets进行访问
```

### 例子

```yaml
# This cluster role binding allows anyone in the "manager" group to read secrets in any namespace.
kind: ClusterRoleBinding
apiversion: rbac.authorization.k8s.io/vlbetal
metadata:
  name: read-secrets-global
subjects:
  kind: Group
  name: manager
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

## Resources

```
Kubernetes集群内一些资源一般以其名称字符串来表示，这些字符串一般会在API的URL地址中出现；
同时某些资源也会包含子资源，例如logs资源就属于pods的子资源，API中URL样例如下:
GET /api/v1/namespaces/{namespace}/pods/{pod}/log
这个{namespace}和{pod}是具体的值，例如
GET /api/v1/namespaces/default/pods/demo-pod/log
就是获取default命名空间下demo-pod的log日志

如果要在RBAC授权模型中控制这些子资源的访问权限，可以通过/分隔符来实现，以下是一个定义
pods资源logs访问权限的Role定义样例
```

### 例子

```yaml
kind: Role
apiversion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default
  name: pod-and-pod-logs-reader
rules：
- apiGroups: [""]
  resources: ["pods/1og"]
  verbs：["get", "list"]
```

## Subject

```
RoleBinding和 ClusterRoleBinding 可以将Role绑定到 Subjects; Subjects 可以是groups、users 或者
service accounts
Subjects中Users使用字符串表示，它可以是一个普通的名字字符串，如“alice”：也可以是email格式
的邮箱地址，如“wangyanglinux@163.com”；甚至是一组字符串形式的数字ID。但是Users的前
缀system：是系统保留的，集群管理员应该确保普通用户不会使用这个前缀格式
Groups书写格式与Users相同，都为一个字符串，并且没有特定的格式要求；同样system:前缀为系统
保留
```

## 创建一个用户只能管理dev名字空间

```
创建证书>转换为kubeconfig文件>创建命名空间>角色绑定

1.创建证书

主节点：
] cd /etc/kubernetes/pki/
] vim dev.json	#使用cdssl工具进行创建
{
  "CN":"devuser",
  "hosts"：[],
  "key":{
    "algo": "rsa",
    "size": 2048
  },
  "names":[
  {
    "C": "CN",
    "ST": "BeiJing",
    "L": "BeiJing",
    "o": "k8s",
    "ou": "system"
  }
 ]
}
#下载证书生成工具
下载cfssl、cfssljson、cfssl-certinfo

] cfssl gencert -ca=ca.crt -ca-key=ca.key profile=kubernetes/root/devuser-
csr.json | cfssljson -bare devuser

会生成三个文件devuser.pem(证书)、devuser.csr(证书签发文件), devuser.key.pem(私钥)


2.生成kubeconfig文件
#设置集群参数
export KUBE_APISERVER="https://192.168.66.11:6443"
kubectl config set-cluster kubernetes \
--certificate-authority=ca.crt \
--embed-certs=true \
--SerVer=S(KUBE_APISERVER} \
--kubeconfig=devuser.kubeconfig

#设置客户端认证参数
kubectl config set-credentials devuser
--client-certificate=devuser.pem
--client-key=devuser-key.pem
--embed-certs=true\
--kubeconfig=devuser.kubeconfig

#设置上下文参数
kubectl config set-context kubernetes
--cluster=kubernetes \
--user=devuser \
-－namespace=dev \
--kubeconfig=devuser.kubeconfig

#设置默认上下文
kubectl config use-context kubernetes --kubeconfig-devuser.kubeconfig

cp -f./devuser.kubeconfig/root/.kube/config

kubectl create rolebinding devuser-admin-binding --clusterrole=admin --
user=devuser --namespace=dev


3.使用该用户
#首先将当前使用的kubeconfig文件移走
] mv /root/.kube/config /root/
#将刚才创建的kubeconfig文件移过来
] cp -a /etc/kubernetes/pki/devuser.kubeconfig /root/.kube/config
这是使用kubectl就是用devuser这个用户
```

## 资源与角色类型的匹配

```
集群级别的资源(Nodes、Pers1stentVolumes)
ClusterRole
ClusterRoleBinding
```

```
非资源型URL(/api、/healthz、..)
ClusterRole
ClusterRoleBinding
```

```
在任何命名空间中的资源（和跨所有命名空间的资源）
ClusterRole
ClusterRoleBinding
```

```
在具体命名空间中的资源（在多个命名空间中重用这个相ClusterRoleRoleBinding同的ClusterRole)
ClusterRole
RoleBinding 
```

```
在具体命名空间中的资源（Role必须在每个命名空间中定义好）
Role
RoleBinding
```



# 准入控制(Admission Control)

```
准入控制是APIServer的插件集合，通过添加不同的插件，实现额外的准入控制规则。甚至于APIServer
的一些主要的功能都需要通过Admission Controllers实现，比如ServiceAccount

准入控制-列举几个插件的功能
◆NamespaceLifecycle：防止在不存在的namespace上创建对象，防止删除系统预置namespace，删
除namespace时，连带删除它的所有资源对象
◆LimitRanger：确保请求的资源不会超过资源所在Namespace的LimitRange的限制
◆ServiceAccount:实现了自动化添加ServiceAccount
◆ResourceQuota：确保请求的资源不会超过资源的ResourceQuota限制

额外功能的添加
有权限但不合理行为的过滤
```

