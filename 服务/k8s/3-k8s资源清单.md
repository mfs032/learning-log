# 什么是资源

k8s中所有内容都被抽象为资源，资源实例化后叫对象

## 常见的资源类别

```
命名空间级别资源：作用范围被限定在某个命名空间内的资源对象，它们的生命周期和可见性都与所属的命名空间绑定
工作负载型资源：Pod、ReplicaSet、Deployment...
服务发现及负载均衡型资源：Service、Ingress...
配置与存储型资源：Volume、CSI...
特殊类型存储卷：ConfigMap、Secret...
```

```
集群级别资源：作用范围覆盖整个集群、不隶属于任何特定命名空间的资源对象。它们的生命周期和可见性与整个集群绑定，而非局限于某个命名空间。

```

```
元数据级别资源：是一类用于描述、配置或定义其他资源属性的特殊资源，它们本身不直接提供业务功能，而是作为集群或其他资源的 “元信息” 存在，用于支撑集群的管理、配置或扩展机制。
```



# 编写资源清单

```yaml
#]# vim 1.pod.yaml
apiVersion: v1
#这是一个缩写，实际上group/apiVersion: core/v1，接口组/版本号
#不同组实现不同功能，版本号则是组对应的不同版本
#比如core的v1版，v2版等
#这相当于告诉k8s集群调动哪个组的哪个版本，

#]kubectl explain 资源类别	#可以看到组和版本
#]kubectl explain pod
#]kubectl explain deployment

kind: Pod
#要创建的资源类别，创建pod就写Pod，kubectl explain pod可以看到类别，以及pod可以写的一些字段，比如metada,spec

metadata: 
#元数据，一些描述信息
  name: pod-demo
  #名称
  namespace: default
  #归属的命名空间
  labels: 
  #标签
    app: myapp

spec:
#期望，声明式表达，没达到期望，会一直尝试达到期望
#通过kubectl explain pod.spec查看可以写哪些字段
  containers: 
  - name: myapp-1
    image: xxx/myapp:v1.0
  - name: busy-box-1
    image: xxx/busy-box-1
    command:
    - "/bin/sh"
    - "-c"
    - "sleep 3600"
#status: 
#状态，描述当前的状态,自定义yaml配置文件无法定义status字段
```

## 简单命令

```shell
] kubectl create -f 1.pod.yaml
#create创建 -f基于文件创建,会根据yaml文件进行实例化
] kubectl get pod -n default
#get 资源 -n指定命名空间
] kubectl get pod -n kube-system
#由于pod是命名空间级别的资源，所以不同命名空间会看到不同的pod，

] kubectl get node -n default
] kubectl get node -n kube-system
#会看到相同的node节点


] kubectl get pod -A
] kubectl get pod --namespaces
#这个可以看到所有命名空间下的pod，包括命名空间

] kubectl get pod -o wide
#-o是option选项，wide是选项，可以看到基本信息额外的一些信息
#比如IP,Node和一些其它的描述信息

] kubectl get pod --show-labels
#查看pod的标签

] kubectl get pod -l app
] kubectl get pod -l app=myapp
#-l根据标签筛选pod，app表示有app这个key的pod，app=myapp等于app=myapp这个键等于值的pod

] kubectl exec -it pod-demo -c myapp-1 -- /bin/bash
#-i表示交互式-t表示打开一个tty终端，-c指定容器name，--表示分割，跟上要执行的命令，可以进入到一个pod的容器内

] kubectl logs pod-demo -c myapp-1
#logs表示查看日志，跟上pod名称,-c指定容器，如果pod里只有两个容器，即只有pause和另一个容器，-c可以不指定


] kubectl get pod pod-demo -n default
] kubectl describe pod pod-demo -n default
#get pod只能看见pod在创建，看不到进行到哪一步。
#使用describe可以看到非常详细的信息
#describe描述的信息中有一个events字段，即时间
#可以看到事件的类型，产生原因，产生时间，来自哪个组件，message

] kubectl delete pod initc-1
#删除某一个pod
] kubectl delete pod --all
#删除当前命名空间所有pod

] kubectl get pod pod-1 -o yaml
#查看pod的yaml格式的信息
```



## 示例：

```yaml
spec:
  containers: 
  - name: myapp-1
    image: xxx/myapp:v1.0
  - name: busy-box-1
    image: xxx/busy-box-1
    command:
    - "/bin/sh"
    - "-c"
    - "sleep 3600"
    
如果pod的期望是这个，里面myapp-1容器启动后会休眠3600s然后退出sh，容器死亡，然后k8s会重建一个新的容器代替旧容器以达到spec的期望
```

```yaml
spec:
  containers: 
  - name: nginx-1
    image: xxx/nginx:v1.0
  - name: nginx-2
    image: xxx/nginx:v2.0

如果pod的配置文件写的像上面这样就要注意了
pod里的容器是共享网络、IPC、PID，即共享端口
如果这两个nginx同时监听80端口就冲突了，第二个容器会一直创建失败，pod会一直尝试重建第二个容器

] kubectl get pod pod-demo会看到一直异常
] kubectl describe pod pod-demo 会看到第二个容器构建失败

] kubectl logs pod-demo -c 第二个容器	查看日志，即报错发现端口已被占用
```

# Pod启动流程



![Pod启动流程](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/Pod%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png)



```
1、首先是initC(init Container初始化容器)启动，准备主容器需要的环境、配置和依赖。初始化容器是按照顺序逐个执行，上一个成功，才执行下一个
2、接着是mainC(main Container主容器)启动，主容器有容器初始化、启动后钩子、启动命令、关闭前钩子、关闭信号
	容器初始化：一些初始化操作，
	启动后钩子：在容器启动后立即执行一些自定义操作。
	启动命令：容器启动时执行的命令
	关闭前钩子：在容器被终止前执行自定义操作
	关闭信号：通知容器即将终止
3、探针：启动探针(startupProbe)、就绪探针(readinessProbe)、存活探针(livenessProbe)
	启动探针：判断应用是否 “完成启动”。启动探针成功前，存活探针和就绪探针不会执行。
	就绪探针：检测容器是否 “就绪”（可以接收请求），如果探测失败，Kubernetes 会将该 Pod 从 Service 的负载均衡池中移除，直到探测成功。
	存活探针：容器内的应用是否 “存活”（正常运行），如果探测失败，Kubernetes 会根据重启策略（restartPolicy）重启容器
```

## initC



### initC的阻塞性

```
initC容器是线性启动的，第一个initC以0状态码退出，才会启动第二个initC,当所有initC以0状态码退出才会创建mainC
```



# 探针

探针是由Pod所在节点的kubelet对容器执行的定期诊断



探针：启动探针(startupProbe)、就绪探针(readinessProbe)、存活探针(livenessProbe)
	启动探针：判断应用是否 “完成启动”。启动探针成功前，存活探针和就绪探针不会执行。
	就绪探针：检测容器是否 “就绪”（可以接收请求），如果探测失败，Kubernetes 会将该 Pod 从 Service 的负载均衡池中移除，直到探测成功。
	存活探针：容器内的应用是否 “存活”（正常运行），如果探测失败，Kubernetes 会根据重启策略（restartPolicy）重启容器



## 实现探针的处理程序

```
有三种：
	ExecAction：在容器内执行指定命令，如果命令返回状态码0，则诊断成功
	TCPSocketAction：对指定端口上的容器的IP地址执行TCP检查。如果端口打开，则成功
	HTTPGetAction：对端口和路径上的容器的IP地址执行HTTP Get请求。如果相应状态码大于等于200小于400，则成功
	
探针每次探测有三种结果：
	成功：容器通过诊断
	失败：容器未通过诊断
	未知：诊断失败，不采取行动
```

## 就绪探针(readinessProbe)

```
检测容器是否准备好给用户访问，若没准备好将Pod从svc的负载均衡池中删去，不给用户访问，在扩容时大量新建Pod很有用

如果pod内c不添加就绪探针，默认就绪。如果添加就绪探针，只有在Pod内所有c都就绪才标记当前Pod就绪
```

#### 选项

```yaml
initialDelaySeconds：容器启动后多少秒探针开始工作
PeriodSeconds：执行探测时间间隔，默认10s，最小1s
timeoutSeconds：探针执行探测请求后等待相应的超时时间
successThreshold：探针检测失败后认为成功的最小连接成功次数，默认1，最小1
failureThreshold：探测失败的重试次数，重试一定次数判断为失败，默认3，最小1
```

#### 示例：HTTPGetAction

![就绪探针-HTTPGetAction](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88-HTTPGetAction.png)

#### 示例：ExecAction

![就绪探针-HTTPGetAction](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88-HTTPGetAction-1755016830652-3.png)

#### 示例：TCPSocketAction

![就绪探针-TCPSocketAction](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88-TCPSocketAction.png)



## 存活探针(liveinessProbe)

如果pod不指定存活探针，可能存在容器运行，但无法提供服务的情况。存活探针和就绪探针最大的区别是探测失败后的动作，一个重启容器，一个从svc负载均衡池删除Pod



成功：静默

失败：根据重启策略进行重启

未知：静默

#### 选项

和就绪探针相似

#### 示例

和就绪探针相似



## 启动探针(startupProbe)

保障存活探针不会因为启动太早导致正在启动的容器被判断为死亡

#### 选项

同就绪探针





# 钩子(hook)

启动后钩子(prestart)和关闭前钩子(poststop)是由k8s管理的kubelet发起的

### ExecAction

![启动后钩子和关闭前钩子-ExecAction](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/%E5%90%AF%E5%8A%A8%E5%90%8E%E9%92%A9%E5%AD%90%E5%92%8C%E5%85%B3%E9%97%AD%E5%89%8D%E9%92%A9%E5%AD%90-ExecAction.png)

### HTTPGetAction

![启动后钩子和关闭前钩子-HTTPGet](3-k8s%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95.assets/%E5%90%AF%E5%8A%A8%E5%90%8E%E9%92%A9%E5%AD%90%E5%92%8C%E5%85%B3%E9%97%AD%E5%89%8D%E9%92%A9%E5%AD%90-HTTPGet.png)
