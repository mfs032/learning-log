# 调度器

## 调度的概念

```
Scheduler时k8s的调度器，主要的任务是把定义的pod调度到集群的节点上。
在pod创建的过程中，状态Pending->Creating->Running，其中这个Pending就是待部署。
```

## 调度的方式

```
Scheduler是作为一个程序在运行的。所以理论上起始可以部署在集群的外面。
Scheduler启动后会一直监听API Server，获取'PodSpec.NodeName'为空的pod，并对每一个pod创建一个binding，表示该pod应该放到哪个节点上

调度要考虑到：
公平：保证每个节点都能被分配资源
资源高效利用：集群的所有资源被最大化使用
效率：调度的新能要好，能够尽快的对大批量的pod完成调度工作
灵活：允许用户根据自己的需求控制调度的逻辑
```

## 调度的过程

```
首先过滤掉不满足条件的节点，这个过程成为"预选"
对节点的优先级进行排序，这个是"优选"
组后选择优先级最高的节点
```

### 预选算法

```
预选算法
PodFitsResources：节点上的剩余的资源是否大于pod请求的资源
PodFitsHost：如果pod制定了NodeName，检查NodeName是否和节点名称匹配
PodFitsHostPorts：节点上已使用的pod是否和pod申请的port冲突
PodSelectorMatches：过滤掉和pod指定的label不匹配的节点
NoDiskConflict：已经mount的volume和pod指定的volume不冲突，除非它们都是只读
等

预选算法的每一步都要通过，如果没通过，pod会一直处于Pending状态，不断重试调度，直到有节点满足条件。
```

### 优选算法

```
优选算法：
LeastRequestedPriority：通过计算CPU和Memory的使用率来决定权重，使用率越低权重越高
BalancedResourceAllocation：节点上的CPU和Memory使用率越接近，权重越高
ImageLocalityPriority：倾向于已有要使用镜像的节点，镜像总大小值越大，权重越高

优选算法可以不满足，最后选择权重最高的节点
```



# 亲和性和反亲和性

## 节点亲和性(nodeAffinity)

```
一种调度的偏好特性
pod.spec.affinity.nodeAffinity
这个pod字段有两个子选项：
preferredDuringSchedulinglgnoredDuringExecution：软性策略，尽量达到，达不到也行
requiredDuringSchedulinglgnoredDuringExecution：硬性策略，一定要达到

```

### 例子-软策略

![pod亲和性](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E4%BA%B2%E5%92%8C%E6%80%A7.png)

```
权重weight是只有在软亲和/软策略中使用值范围1到100,表示规则的重要性，权重越高，调度器尝试调度时如果满足这个偏好，给予的分数就越高
```



### 例子-硬策略

![pod亲和性-硬策略](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E4%BA%B2%E5%92%8C%E6%80%A7-%E7%A1%AC%E7%AD%96%E7%95%A5.png)

## 节点反亲和性(nodeAntiAffinity)

### 例子-软策略



### 例子-硬策略



## pod亲和性(podAffinity)

### 例子-软策略

![pod亲和性-软策略](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E4%BA%B2%E5%92%8C%E6%80%A7-%E8%BD%AF%E7%AD%96%E7%95%A5.png)

```
topologyKey字段指定的是拓扑域。
首先调度器会去匹配labelSelector匹配到的pod，根据指定的key-value会匹配到对应的pod。
匹配到的这个pod所在的节点的标签里，有没有拓扑域(topologyKey)指定的key，有这个key，就把这个key-value再拿出来匹配。
所有带这个key-value的节点都属于同一个拓扑域，被调度的pod可以部署在这些节点中的任意一个节点上
```

### 例子-硬策略

![pod亲和性-硬策略](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E4%BA%B2%E5%92%8C%E6%80%A7-%E7%A1%AC%E7%AD%96%E7%95%A5-1757004899895-4.png)





##  pod反亲和性(podAntiAffinity)

```
配置内容和pod亲和性相同，只是把spec.affinity.podAffinity改成soec.affinity.AntiAffinity，匹配条件从匹配变成不匹配
```

### 例子-软策略

![pod反亲和性-软策略](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E5%8F%8D%E4%BA%B2%E5%92%8C%E6%80%A7-%E8%BD%AF%E7%AD%96%E7%95%A5.png)

```
匹配这个pod，和这个pod不在同一个拓扑域
```

### 例子-硬策略

![pod反亲和性-硬策略](7-k8s%E8%B0%83%E5%BA%A6%E5%99%A8.assets/pod%E5%8F%8D%E4%BA%B2%E5%92%8C%E6%80%A7-%E7%A1%AC%E7%AD%96%E7%95%A5.png)



# 污点(Taint)和容忍(toleration)

```
Taint和toleration互相配合，可以用来避免pod被分配到不合适的节点上。每一个节点上都可以应用一个或多个污点(Taint)。这表示对于那些不能容忍这些taint的pod，是不会被该节点接受的。如果将容忍(toleration)应用到pod上，则表示这些pod可以被调度到具有匹配taint的节点上
```



## 污点-组成

```
key=value:effect
每个污点有一个key和value作为污点的标签，其中value可以为空，effect描述污点的作用。当前污点的effect支持如下三个选项：
NoSchedule：表示k8s将不会将Pod调度到具有该污点的Node上
PreferNoSchedule：表示k8s尽量避免将Pod调度到该节点上
NoExecute：k8s不会讲Pod调度到具有该污点的Node上，同时会将Node上已经存在的Pod驱逐出去
```

```
k8s的master节点默认是不会调度Pod到该节点上的，就是因为该节点有污点
] kubectl describe node k8s-master01
里面有个Taints字段，表示该节点的污点，例如:
node-role.kubernetes.io/control-plane:NoSchedule	#该污点value为空，所以没有=value，只有key和effect
```

### 添加污点

```
#添加污点
] kubectl taint node k8s-master01 computerengine=gpu:NoSchedule
#查看污点
] kubectl describe node k8s-master01

#移除污点，处理命令的方式也可以通过配置文件修改
] kubectl taint k8s-master01 computerengine=gpu:NoSchedule-


如果想要利用master节点的资源，可以将master节点的污点改成PreferNoSchedule，这样其它节点压力不大的时候master节点不会被pod调度，当其它节点压力大时，会调度一定的pod到master节点，减轻压力，充分利用资源
] kubectl taint k8s-master01 node-role.kubernetes.io/control-plane=:NoSchedule-
] kubectl taint k8s-master01 node-role.kubernetes.io/control-plane=:PreferNoSchedule
```

## 容忍-概念

```
设置了污点的Node讲根据taint的effect：NoSchedule、PerferNoSchedule、NoExecute和Pod之间产生互斥的关系，Pod将在一定程度上不会被调度到Node上。
但我们可以在Pod上设置容忍(Toleration)，设置了容忍的Pod将可以容忍污点的存在，可以被调度到存在污点的Node上
```

### 容忍-设置方式

```
tolerations:
- key: "key1"
  operator: "Equal"
  value: "value1"
  effect: "NoSchedule"
  
或者
tolerations:
- key: "key1"
  operator: "Equal"
  value: "value1"
  effect: "NoExecute"
  tolerationSeconds: 3600	#容忍时间，pod可以在该节点上存在的时间
  
 
当不指定value时，表示容忍所有的污点value
toleration:
- key: "key2"
  operator: "Exists"
  effect: "NoSchedule"
  
当不指定key时，表示容忍所有的污点
toleration:
- operator: "Exists"
```



# 固定节点调度

## 指定节点进行调度

```
在pod的spec.nodeName字段指定node名称，会跳过调度器调度策略，该规则是强制匹配
```

## 指定节点标签选择器调度

```
pod.spec.nodeSelector通过标签选择器机制选择节点，有调度器调度策略匹配label，而后调度Pod到目标节点，该匹配规则属于强制匹配，但任然会经过调度器调度。效果相当于硬亲和
spec:
  nodeSelector:
    app=app01
```

